<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>lwpa: lwpa_rootlayerpdu</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="etcdevtool.css" rel="stylesheet" type="text/css"/>
<!-- BEGIN CUSTOM SCRIPTS -->
<!-- BEGIN ETCDEVTOOL VERSION SELECTOR SCRIPT -->
<script type="text/javascript">
  $(function () {
    $.get('/EtcPalDocs/versions.txt', function (data) {
      if (data) {
        var lines = data.split('\n');
        if (lines.length > 0) {
          var version_select = $("#version_select").empty();
          lines.forEach(function (line) {
            line = line.trim();
            if (!line) {
              return;
            }
            line = line.split(':');
            var option_name = line[0].replace(/^v/, '');
            if (line.length > 1) {
              option_name += ' (' + line[1] + ')';
            }
            var option_val = '/EtcPalDocs/' + line[0];
            var option = $('<option></option>').attr("value", option_val)
              .text(option_name);
            if (window.location.pathname.match(line[0])) {
              option = option.attr("selected", "selected");
            }
            version_select.append(option);
          });
        }
      }
    }, 'text');
  });
</script>
<!-- END ETCDEVTOOL VERSION SELECTOR SCRIPT -->
<script type="text/javascript">
  $(function () { selectAllC() });
</script>
<script type="text/javascript">
  function selectAllC() {
    // Enable all C-language blocks
    var tabcontent = document.getElementsByClassName("code-tab-content");
    for (i = 0; i < tabcontent.length; i++) {
      if (tabcontent[i].id.endsWith("_c")) {
        tabcontent[i].style.display = "block";
      } else {
        tabcontent[i].style.display = "none"
      }
    }
    // Enable all C-language buttons
    var tablinks = document.getElementsByClassName("code-tab-links");
    for (i = 0; i < tablinks.length; i++) {
      if (tablinks[i].id.endsWith("_c")) {
        if (!tablinks[i].className.includes("active")) {
          tablinks[i].className = tablinks[i].className += " active";
        }
      } else {
        tablinks[i].className = tablinks[i].className.replace(" active", "");
      }
    }
  }
  function selectAllCpp() {
    // Enable all C++-language blocks
    var tabcontent = document.getElementsByClassName("code-tab-content");
    for (i = 0; i < tabcontent.length; i++) {
      if (tabcontent[i].id.endsWith("_cpp")) {
        tabcontent[i].style.display = "block";
      } else {
        tabcontent[i].style.display = "none"
      }
    }
    // Enable all C++-language buttons
    var tablinks = document.getElementsByClassName("code-tab-links");
    for (i = 0; i < tablinks.length; i++) {
      if (tablinks[i].id.endsWith("_cpp")) {
        if (!tablinks[i].className.includes("active")) {
          tablinks[i].className = tablinks[i].className += " active";
        }
      } else {
        tablinks[i].className = tablinks[i].className.replace(" active", "");
      }
    }
  }
  function selectLanguage(evt, block_id, language) {
    // Get all elements with class="tabcontent" and hide them
    var tabcontent = document.getElementsByClassName("code-tab-content");
    for (i = 0; i < tabcontent.length; i++) {
      if (tabcontent[i].id.startsWith("div_" + block_id)) {
        tabcontent[i].style.display = "none";
      }
    }
    // Get all elements with class="tablinks" and remove the class "active"
    var tablinks = document.getElementsByClassName("code-tab-links");
    for (i = 0; i < tablinks.length; i++) {
      if (tablinks[i].id.startsWith("button_" + block_id)) {
        tablinks[i].className = tablinks[i].className.replace(" active", "");
      }
    }
    // Show the current tab, and add an "active" class to the button that opened the tab
    document.getElementById("div_" + block_id + "_" + language).style.display = "block";
    if (!evt.currentTarget.className.includes("active")) {
      evt.currentTarget.className += " active";
    }
  }
</script>
<!-- END CUSTOM SCRIPTS -->
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">lwpa
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
   <div id="projectbrief">LightWeight Platform Abstraction (lwpa)</div>
  </td>
  <!-- BEGIN VERSION SELECTOR INSERTED BY ETCDEVTOOL -->
  <td style="text-align: right; padding-right: 0.5em">
    <div id="otherversions">
      View other versions:
      <select id="version_select" onchange="location = this.value">
      </select>
    </div>
  </td>
  <!-- END VERSION SELECTOR INSERTED BY ETCDEVTOOL -->
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__lwpa__rootlayerpdu.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">lwpa_rootlayerpdu<div class="ingroups"><a class="el" href="group__lwpa.html">lwpa</a> &raquo; <a class="el" href="group__lwpa__pdu.html">lwpa_pdu</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Overview</h2>
<p>Parse or pack a Root Layer PDU block. </p>
<p>#include "lwpa_rootlayerpdu.h" </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tcp_preamble.html">TcpPreamble</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds the information contained in an ACN TCP Preamble.  <a href="struct_tcp_preamble.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_udp_preamble.html">UdpPreamble</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds the information contained in an ACN UDP Preamble.  <a href="struct_udp_preamble.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_root_layer_pdu.html">RootLayerPdu</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds the information contained in an ACN Root Layer PDU.  <a href="struct_root_layer_pdu.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gab879b13847509e3bbd4b12a5e2cda0e7"><td class="memItemLeft" align="right" valign="top"><a id="gab879b13847509e3bbd4b12a5e2cda0e7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwpa__rootlayerpdu.html#gab879b13847509e3bbd4b12a5e2cda0e7">ACN_TCP_PREAMBLE_SIZE</a>&#160;&#160;&#160;16</td></tr>
<tr class="memdesc:gab879b13847509e3bbd4b12a5e2cda0e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of an ACN family TCP preamble. <br /></td></tr>
<tr class="separator:gab879b13847509e3bbd4b12a5e2cda0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86207e41512354a1a6e321d95afe8ab0"><td class="memItemLeft" align="right" valign="top"><a id="ga86207e41512354a1a6e321d95afe8ab0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwpa__rootlayerpdu.html#ga86207e41512354a1a6e321d95afe8ab0">ACN_UDP_PREAMBLE_SIZE</a>&#160;&#160;&#160;16</td></tr>
<tr class="memdesc:ga86207e41512354a1a6e321d95afe8ab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of an ACN family UDP preamble. <br /></td></tr>
<tr class="separator:ga86207e41512354a1a6e321d95afe8ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga592d004ced57212084bb1760304ea7cc"><td class="memItemLeft" align="right" valign="top"><a id="ga592d004ced57212084bb1760304ea7cc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwpa__rootlayerpdu.html#ga592d004ced57212084bb1760304ea7cc">RLP_HEADER_SIZE_NORMAL_LEN</a>&#160;&#160;&#160;22</td></tr>
<tr class="memdesc:ga592d004ced57212084bb1760304ea7cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of a Root Layer PDU header when the length is less than 4096. <br /></td></tr>
<tr class="separator:ga592d004ced57212084bb1760304ea7cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b0720c08ac5b029b98f25a74906787a"><td class="memItemLeft" align="right" valign="top"><a id="ga3b0720c08ac5b029b98f25a74906787a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwpa__rootlayerpdu.html#ga3b0720c08ac5b029b98f25a74906787a">RLP_HEADER_SIZE_EXT_LEN</a>&#160;&#160;&#160;23</td></tr>
<tr class="memdesc:ga3b0720c08ac5b029b98f25a74906787a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the Root Layer PDU header when the length is 4096 or greater. <br /></td></tr>
<tr class="separator:ga3b0720c08ac5b029b98f25a74906787a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga6fc6111bc540bdb2413a9f98bbc95ca4"><td class="memItemLeft" align="right" valign="top"><a id="ga6fc6111bc540bdb2413a9f98bbc95ca4"></a>
typedef struct <a class="el" href="struct_tcp_preamble.html">TcpPreamble</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwpa__rootlayerpdu.html#ga6fc6111bc540bdb2413a9f98bbc95ca4">TcpPreamble</a></td></tr>
<tr class="memdesc:ga6fc6111bc540bdb2413a9f98bbc95ca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds the information contained in an ACN TCP Preamble. <br /></td></tr>
<tr class="separator:ga6fc6111bc540bdb2413a9f98bbc95ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78f6296e83e0f028566c0a5ede73188d"><td class="memItemLeft" align="right" valign="top"><a id="ga78f6296e83e0f028566c0a5ede73188d"></a>
typedef struct <a class="el" href="struct_udp_preamble.html">UdpPreamble</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwpa__rootlayerpdu.html#ga78f6296e83e0f028566c0a5ede73188d">UdpPreamble</a></td></tr>
<tr class="memdesc:ga78f6296e83e0f028566c0a5ede73188d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds the information contained in an ACN UDP Preamble. <br /></td></tr>
<tr class="separator:ga78f6296e83e0f028566c0a5ede73188d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1eb2da0d3045217e117851856c6f8a7"><td class="memItemLeft" align="right" valign="top"><a id="gab1eb2da0d3045217e117851856c6f8a7"></a>
typedef struct <a class="el" href="struct_root_layer_pdu.html">RootLayerPdu</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwpa__rootlayerpdu.html#gab1eb2da0d3045217e117851856c6f8a7">RootLayerPdu</a></td></tr>
<tr class="memdesc:gab1eb2da0d3045217e117851856c6f8a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds the information contained in an ACN Root Layer PDU. <br /></td></tr>
<tr class="separator:gab1eb2da0d3045217e117851856c6f8a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga5504243cf58e317bc0f61ccb3191d80d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__lwpa__bool.html#gabb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwpa__rootlayerpdu.html#ga5504243cf58e317bc0f61ccb3191d80d">parse_tcp_preamble</a> (const uint8_t *buf, size_t buflen, <a class="el" href="struct_tcp_preamble.html">TcpPreamble</a> *preamble)</td></tr>
<tr class="memdesc:ga5504243cf58e317bc0f61ccb3191d80d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an ACN TCP Preamble.  <a href="group__lwpa__rootlayerpdu.html#ga5504243cf58e317bc0f61ccb3191d80d">More...</a><br /></td></tr>
<tr class="separator:ga5504243cf58e317bc0f61ccb3191d80d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0be0e22c075acfbbea4330cf1bec23c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__lwpa__bool.html#gabb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwpa__rootlayerpdu.html#gae0be0e22c075acfbbea4330cf1bec23c">parse_udp_preamble</a> (const uint8_t *buf, size_t buflen, <a class="el" href="struct_udp_preamble.html">UdpPreamble</a> *preamble)</td></tr>
<tr class="memdesc:gae0be0e22c075acfbbea4330cf1bec23c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an ACN UDP Preamble.  <a href="group__lwpa__rootlayerpdu.html#gae0be0e22c075acfbbea4330cf1bec23c">More...</a><br /></td></tr>
<tr class="separator:gae0be0e22c075acfbbea4330cf1bec23c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6f5d91d9ae4549dc6af9ab2aa59b7e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__lwpa__bool.html#gabb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwpa__rootlayerpdu.html#gac6f5d91d9ae4549dc6af9ab2aa59b7e8">parse_root_layer_header</a> (const uint8_t *buf, size_t buflen, <a class="el" href="struct_root_layer_pdu.html">RootLayerPdu</a> *pdu, <a class="el" href="struct_root_layer_pdu.html">RootLayerPdu</a> *last_pdu)</td></tr>
<tr class="memdesc:gac6f5d91d9ae4549dc6af9ab2aa59b7e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse only the header of a Root Layer PDU.  <a href="group__lwpa__rootlayerpdu.html#gac6f5d91d9ae4549dc6af9ab2aa59b7e8">More...</a><br /></td></tr>
<tr class="separator:gac6f5d91d9ae4549dc6af9ab2aa59b7e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16a05260696331878fe93a454dee8e79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__lwpa__bool.html#gabb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwpa__rootlayerpdu.html#ga16a05260696331878fe93a454dee8e79">parse_root_layer_pdu</a> (const uint8_t *buf, size_t buflen, <a class="el" href="struct_root_layer_pdu.html">RootLayerPdu</a> *pdu, <a class="el" href="struct_lwpa_pdu.html">LwpaPdu</a> *last_pdu)</td></tr>
<tr class="memdesc:ga16a05260696331878fe93a454dee8e79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a Root Layer PDU.  <a href="group__lwpa__rootlayerpdu.html#ga16a05260696331878fe93a454dee8e79">More...</a><br /></td></tr>
<tr class="separator:ga16a05260696331878fe93a454dee8e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga470dcd083be11e88e26381ce4f1a7b17"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwpa__rootlayerpdu.html#ga470dcd083be11e88e26381ce4f1a7b17">pack_tcp_preamble</a> (uint8_t *buf, size_t buflen, size_t rlp_block_len)</td></tr>
<tr class="memdesc:ga470dcd083be11e88e26381ce4f1a7b17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack an ACN TCP Preamble into a buffer.  <a href="group__lwpa__rootlayerpdu.html#ga470dcd083be11e88e26381ce4f1a7b17">More...</a><br /></td></tr>
<tr class="separator:ga470dcd083be11e88e26381ce4f1a7b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa95aeb9aa4ca18f8ed26a6523ea9a2c5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwpa__rootlayerpdu.html#gaa95aeb9aa4ca18f8ed26a6523ea9a2c5">pack_udp_preamble</a> (uint8_t *buf, size_t buflen)</td></tr>
<tr class="memdesc:gaa95aeb9aa4ca18f8ed26a6523ea9a2c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack an ACN UDP Preamble into a buffer.  <a href="group__lwpa__rootlayerpdu.html#gaa95aeb9aa4ca18f8ed26a6523ea9a2c5">More...</a><br /></td></tr>
<tr class="separator:gaa95aeb9aa4ca18f8ed26a6523ea9a2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf778285bf86d4d5e8eaf673492fd06a6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwpa__rootlayerpdu.html#gaf778285bf86d4d5e8eaf673492fd06a6">root_layer_buf_size</a> (const <a class="el" href="struct_root_layer_pdu.html">RootLayerPdu</a> *pdu_block, size_t num_pdus)</td></tr>
<tr class="memdesc:gaf778285bf86d4d5e8eaf673492fd06a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the buffer size to allocate for a Root Layer PDU block.  <a href="group__lwpa__rootlayerpdu.html#gaf778285bf86d4d5e8eaf673492fd06a6">More...</a><br /></td></tr>
<tr class="separator:gaf778285bf86d4d5e8eaf673492fd06a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga508b6176f6fa96d9a22fad3e87d0379b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwpa__rootlayerpdu.html#ga508b6176f6fa96d9a22fad3e87d0379b">pack_root_layer_header</a> (uint8_t *buf, size_t buflen, const <a class="el" href="struct_root_layer_pdu.html">RootLayerPdu</a> *pdu)</td></tr>
<tr class="memdesc:ga508b6176f6fa96d9a22fad3e87d0379b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack only the header of a Root Layer PDU block into a buffer.  <a href="group__lwpa__rootlayerpdu.html#ga508b6176f6fa96d9a22fad3e87d0379b">More...</a><br /></td></tr>
<tr class="separator:ga508b6176f6fa96d9a22fad3e87d0379b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga577897f50c0a7a5a78abe74b07520184"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lwpa__rootlayerpdu.html#ga577897f50c0a7a5a78abe74b07520184">pack_root_layer_block</a> (uint8_t *buf, size_t buflen, const <a class="el" href="struct_root_layer_pdu.html">RootLayerPdu</a> *pdu_block, size_t num_pdus)</td></tr>
<tr class="memdesc:ga577897f50c0a7a5a78abe74b07520184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack a Root Layer PDU block into a buffer.  <a href="group__lwpa__rootlayerpdu.html#ga577897f50c0a7a5a78abe74b07520184">More...</a><br /></td></tr>
<tr class="separator:ga577897f50c0a7a5a78abe74b07520184"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Protocol Vectors</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp2980e542e3b6f126c15c92b8ec2c9c91"></a>Each ACN family protocol is defined by a protocol vector in a Root Layer PDU.</p>
<p>These values occupy the vector field of a <a class="el" href="struct_root_layer_pdu.html" title="Holds the information contained in an ACN Root Layer PDU.">RootLayerPdu</a> to identify the contents of its data segment. </p>
</td></tr>
<tr class="memitem:gaafde356ccc6bb337fab575bd5f2c3703"><td class="memItemLeft" align="right" valign="top"><a id="gaafde356ccc6bb337fab575bd5f2c3703"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>VECTOR_ROOT_SDT</b>&#160;&#160;&#160;ACN_PROTOCOL_SDT</td></tr>
<tr class="separator:gaafde356ccc6bb337fab575bd5f2c3703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e6aecaf6b186f2f89a7437ffabefe29"><td class="memItemLeft" align="right" valign="top"><a id="ga9e6aecaf6b186f2f89a7437ffabefe29"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>VECTOR_ROOT_DRAFT_E131_DATA</b>&#160;&#160;&#160;ACN_PROTOCOL_DRAFT_E131_DATA</td></tr>
<tr class="separator:ga9e6aecaf6b186f2f89a7437ffabefe29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf04e60c493a229a78eaf3c1bbaff3af1"><td class="memItemLeft" align="right" valign="top"><a id="gaf04e60c493a229a78eaf3c1bbaff3af1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>VECTOR_ROOT_E131_DATA</b>&#160;&#160;&#160;ACN_PROTOCOL_E131_DATA</td></tr>
<tr class="separator:gaf04e60c493a229a78eaf3c1bbaff3af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd3c2e14a24bd4de4d461ab93a0ae0a4"><td class="memItemLeft" align="right" valign="top"><a id="gabd3c2e14a24bd4de4d461ab93a0ae0a4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>VECTOR_ROOT_E131_EXTENDED</b>&#160;&#160;&#160;ACN_PROTOCOL_E131_EXTENDED</td></tr>
<tr class="separator:gabd3c2e14a24bd4de4d461ab93a0ae0a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0a557743060afe9777faf016f6bc565"><td class="memItemLeft" align="right" valign="top"><a id="gaa0a557743060afe9777faf016f6bc565"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>VECTOR_ROOT_LLRP</b>&#160;&#160;&#160;ACN_PROTOCOL_LLRP</td></tr>
<tr class="separator:gaa0a557743060afe9777faf016f6bc565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga833a0e21c6c5ce45595dfaacca80f4cf"><td class="memItemLeft" align="right" valign="top"><a id="ga833a0e21c6c5ce45595dfaacca80f4cf"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>VECTOR_ROOT_BROKER</b>&#160;&#160;&#160;ACN_PROTOCOL_BROKER</td></tr>
<tr class="separator:ga833a0e21c6c5ce45595dfaacca80f4cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb3e480eae15b5f35b31d0bafde8f38f"><td class="memItemLeft" align="right" valign="top"><a id="gafb3e480eae15b5f35b31d0bafde8f38f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>VECTOR_ROOT_RPT</b>&#160;&#160;&#160;ACN_PROTOCOL_RPT</td></tr>
<tr class="separator:gafb3e480eae15b5f35b31d0bafde8f38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5241d6e6a2c015d4fb82833f5857ac79"><td class="memItemLeft" align="right" valign="top"><a id="ga5241d6e6a2c015d4fb82833f5857ac79"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>VECTOR_ROOT_EPT</b>&#160;&#160;&#160;ACN_PROTOCOL_EPT</td></tr>
<tr class="separator:ga5241d6e6a2c015d4fb82833f5857ac79"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga577897f50c0a7a5a78abe74b07520184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga577897f50c0a7a5a78abe74b07520184">&#9670;&nbsp;</a></span>pack_root_layer_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t pack_root_layer_block </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buflen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_root_layer_pdu.html">RootLayerPdu</a> *&#160;</td>
          <td class="paramname"><em>pdu_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_pdus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pack a Root Layer PDU block into a buffer. </p>
<p>The required buffer size can be calculated in advance using <a class="el" href="group__lwpa__rootlayerpdu.html#gaf778285bf86d4d5e8eaf673492fd06a6" title="Get the buffer size to allocate for a Root Layer PDU block.">root_layer_buf_size()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Buffer into which to pack the Root Layer PDU block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buflen</td><td>Size in bytes of buf. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pdu_block</td><td>Array of <a class="el" href="struct_root_layer_pdu.html" title="Holds the information contained in an ACN Root Layer PDU.">RootLayerPdu</a> representing the PDU block to pack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_pdus</td><td>Number of <a class="el" href="struct_root_layer_pdu.html" title="Holds the information contained in an ACN Root Layer PDU.">RootLayerPdu</a> that make up the pdu_block array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes packed (success) or 0 (failure). Note that this might be less than the value returned by <a class="el" href="group__lwpa__rootlayerpdu.html#gaf778285bf86d4d5e8eaf673492fd06a6" title="Get the buffer size to allocate for a Root Layer PDU block.">root_layer_buf_size()</a>; this is because this function performs more optimizations related to PDU inheritance. </dd></dl>

</div>
</div>
<a id="ga508b6176f6fa96d9a22fad3e87d0379b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga508b6176f6fa96d9a22fad3e87d0379b">&#9670;&nbsp;</a></span>pack_root_layer_header()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t pack_root_layer_header </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buflen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_root_layer_pdu.html">RootLayerPdu</a> *&#160;</td>
          <td class="paramname"><em>pdu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pack only the header of a Root Layer PDU block into a buffer. </p>
<p>This can be useful when working with stream sockets.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Buffer into which to pack the Root Layer PDU header. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buflen</td><td>Size in bytes of buf. Buffer should be at least of size <a class="el" href="group__lwpa__rootlayerpdu.html#ga3b0720c08ac5b029b98f25a74906787a" title="Size of the Root Layer PDU header when the length is 4096 or greater.">RLP_HEADER_SIZE_EXT_LEN</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pdu</td><td>PDU for which to pack the header into a buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes packed (success) or 0 (failure). </dd></dl>

</div>
</div>
<a id="ga470dcd083be11e88e26381ce4f1a7b17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga470dcd083be11e88e26381ce4f1a7b17">&#9670;&nbsp;</a></span>pack_tcp_preamble()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t pack_tcp_preamble </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buflen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rlp_block_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pack an ACN TCP Preamble into a buffer. </p>
<p>All ACN protocol family packets sent over TCP must start with a TCP Preamble.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Buffer into which to pack the preamble. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buflen</td><td>Size in bytes of buf. Buffer should be at least of length <a class="el" href="group__lwpa__rootlayerpdu.html#gab879b13847509e3bbd4b12a5e2cda0e7" title="Size of an ACN family TCP preamble.">ACN_TCP_PREAMBLE_SIZE</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rlp_block_len</td><td>Full length in bytes of the Root Layer PDU block that will come after this TCP preamble. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes packed (success) or 0 (failure). </dd></dl>

</div>
</div>
<a id="gaa95aeb9aa4ca18f8ed26a6523ea9a2c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa95aeb9aa4ca18f8ed26a6523ea9a2c5">&#9670;&nbsp;</a></span>pack_udp_preamble()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t pack_udp_preamble </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buflen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pack an ACN UDP Preamble into a buffer. </p>
<p>All ACN protocol family packets sent over UDP must start with a UDP Preamble.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Buffer into which to pack the preamble. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buflen</td><td>Size in bytes of buf. Buffer should be at least of length <a class="el" href="group__lwpa__rootlayerpdu.html#ga86207e41512354a1a6e321d95afe8ab0" title="Size of an ACN family UDP preamble.">ACN_UDP_PREAMBLE_SIZE</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes packed (success) or 0 (failure). </dd></dl>

</div>
</div>
<a id="gac6f5d91d9ae4549dc6af9ab2aa59b7e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6f5d91d9ae4549dc6af9ab2aa59b7e8">&#9670;&nbsp;</a></span>parse_root_layer_header()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__lwpa__bool.html#gabb452686968e48b67397da5f97445f5b">bool</a> parse_root_layer_header </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buflen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_root_layer_pdu.html">RootLayerPdu</a> *&#160;</td>
          <td class="paramname"><em>pdu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_root_layer_pdu.html">RootLayerPdu</a> *&#160;</td>
          <td class="paramname"><em>last_pdu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse only the header of a Root Layer PDU. </p>
<p>This can be useful when working with stream sockets.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Root Layer Protocol buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buflen</td><td>Size in bytes of buf. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pdu</td><td>Struct to contain parsed PDU header. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last_pdu</td><td>The last PDU structure that was parsed by this function, or NULL for the first PDU in the block. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true (PDU was parsed successfully) or false (parse error or no more PDUs in the block). </dd></dl>

</div>
</div>
<a id="ga16a05260696331878fe93a454dee8e79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16a05260696331878fe93a454dee8e79">&#9670;&nbsp;</a></span>parse_root_layer_pdu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__lwpa__bool.html#gabb452686968e48b67397da5f97445f5b">bool</a> parse_root_layer_pdu </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buflen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_root_layer_pdu.html">RootLayerPdu</a> *&#160;</td>
          <td class="paramname"><em>pdu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_lwpa_pdu.html">LwpaPdu</a> *&#160;</td>
          <td class="paramname"><em>last_pdu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a Root Layer PDU. </p>
<p>Parse a Root Layer PDU from a Root Layer PDU block. Fills in the root_layer_pdu structure with the parsed PDU information, and stores state data in a pdu structure for parsing the next PDU in the block, if there is one.</p>
<p>Example usage:</p>
<p>After parsing an ACN protocol family preamble (perhaps by using <a class="el" href="group__lwpa__rootlayerpdu.html#gae0be0e22c075acfbbea4330cf1bec23c" title="Parse an ACN UDP Preamble.">parse_udp_preamble()</a> or <a class="el" href="group__lwpa__rootlayerpdu.html#ga5504243cf58e317bc0f61ccb3191d80d" title="Parse an ACN TCP Preamble.">parse_tcp_preamble()</a>), buf points to the data starting after the preamble and buflen is the length parsed from the preamble...</p>
<div class="fragment"><div class="line"><a class="code" href="struct_lwpa_pdu.html">LwpaPdu</a> pdu = <a class="code" href="group__lwpa__pdu.html#ga5263d5874200e90de739e1cf453078ef">PDU_INIT</a>; <span class="comment">// Must initialize this!!</span></div>
<div class="line"><span class="keywordtype">bool</span> res = <span class="keyword">false</span>;</div>
<div class="line"><span class="keywordflow">do</span></div>
<div class="line">{</div>
<div class="line">    <a class="code" href="struct_root_layer_pdu.html">RootLayerPdu</a> cur;</div>
<div class="line">    res = <a class="code" href="group__lwpa__rootlayerpdu.html#ga16a05260696331878fe93a454dee8e79">parse_root_layer_pdu</a>(buf, buflen, &amp;cur, &amp;pdu);</div>
<div class="line">    <span class="keywordflow">if</span> (res)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Example application handler function that forwards the pdu</span></div>
<div class="line">        <span class="comment">// appropriately based on vector</span></div>
<div class="line">        handle_root_layer_pdu(&amp;cur);</div>
<div class="line">    }</div>
<div class="line">} <span class="keywordflow">while</span> (res);</div>
<div class="ttc" id="agroup__lwpa__pdu_html_ga5263d5874200e90de739e1cf453078ef"><div class="ttname"><a href="group__lwpa__pdu.html#ga5263d5874200e90de739e1cf453078ef">PDU_INIT</a></div><div class="ttdeci">#define PDU_INIT</div><div class="ttdoc">Default LwpaPdu initializer values; must be used to intialize a struct pdu when parsing the first PDU...</div><div class="ttdef"><b>Definition:</b> lwpa_pdu.h:126</div></div>
<div class="ttc" id="agroup__lwpa__rootlayerpdu_html_ga16a05260696331878fe93a454dee8e79"><div class="ttname"><a href="group__lwpa__rootlayerpdu.html#ga16a05260696331878fe93a454dee8e79">parse_root_layer_pdu</a></div><div class="ttdeci">bool parse_root_layer_pdu(const uint8_t *buf, size_t buflen, RootLayerPdu *pdu, LwpaPdu *last_pdu)</div><div class="ttdoc">Parse a Root Layer PDU.</div><div class="ttdef"><b>Definition:</b> lwpa_rootlayerpdu.c:209</div></div>
<div class="ttc" id="astruct_lwpa_pdu_html"><div class="ttname"><a href="struct_lwpa_pdu.html">LwpaPdu</a></div><div class="ttdoc">Holds state data used when parsing multiple PDUs in a PDU block.</div><div class="ttdef"><b>Definition:</b> lwpa_pdu.h:116</div></div>
<div class="ttc" id="astruct_root_layer_pdu_html"><div class="ttname"><a href="struct_root_layer_pdu.html">RootLayerPdu</a></div><div class="ttdoc">Holds the information contained in an ACN Root Layer PDU.</div><div class="ttdef"><b>Definition:</b> lwpa_rootlayerpdu.h:86</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Root Layer Protocol buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buflen</td><td>Size in bytes of buf. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pdu</td><td>Struct to contain parsed PDU. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">last_pdu</td><td>State data for future calls. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true (PDU was parsed successfully) or false (parse error or no more PDUs in the block). </dd></dl>

</div>
</div>
<a id="ga5504243cf58e317bc0f61ccb3191d80d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5504243cf58e317bc0f61ccb3191d80d">&#9670;&nbsp;</a></span>parse_tcp_preamble()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__lwpa__bool.html#gabb452686968e48b67397da5f97445f5b">bool</a> parse_tcp_preamble </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buflen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_tcp_preamble.html">TcpPreamble</a> *&#160;</td>
          <td class="paramname"><em>preamble</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse an ACN TCP Preamble. </p>
<p>Determine whether this byte buffer, received over TCP, starts with an ACN TCP Preamble and thus contains an ACN protocol family packet. For best results, wait until you receive at least <a class="el" href="group__lwpa__rootlayerpdu.html#gab879b13847509e3bbd4b12a5e2cda0e7" title="Size of an ACN family TCP preamble.">ACN_TCP_PREAMBLE_SIZE</a> bytes before calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Received TCP buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buflen</td><td>Size in bytes of buf. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">preamble</td><td>Struct to contain parsed preamble information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true (preamble was parsed successfully) or false (buffer too short or buffer does not contain a valid TCP preamble). </dd></dl>

</div>
</div>
<a id="gae0be0e22c075acfbbea4330cf1bec23c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0be0e22c075acfbbea4330cf1bec23c">&#9670;&nbsp;</a></span>parse_udp_preamble()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__lwpa__bool.html#gabb452686968e48b67397da5f97445f5b">bool</a> parse_udp_preamble </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buflen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_udp_preamble.html">UdpPreamble</a> *&#160;</td>
          <td class="paramname"><em>preamble</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse an ACN UDP Preamble. </p>
<p>Determine whether this received UDP datagram contains an ACN protocol family packet by determining whether it starts with the ACN UDP preamble.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Received UDP buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buflen</td><td>Size in bytes of buf. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">preamble</td><td>Struct to contain parsed preamble information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true (preamble was parsed successfully) or false (buffer too short or buffer does not contain a valid UDP preamble). </dd></dl>

</div>
</div>
<a id="gaf778285bf86d4d5e8eaf673492fd06a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf778285bf86d4d5e8eaf673492fd06a6">&#9670;&nbsp;</a></span>root_layer_buf_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t root_layer_buf_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_root_layer_pdu.html">RootLayerPdu</a> *&#160;</td>
          <td class="paramname"><em>pdu_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_pdus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the buffer size to allocate for a Root Layer PDU block. </p>
<p>Calculate the buffer size to allocate for a future call to <a class="el" href="group__lwpa__rootlayerpdu.html#ga577897f50c0a7a5a78abe74b07520184" title="Pack a Root Layer PDU block into a buffer.">pack_root_layer_block()</a>, given an array of struct root_layer_pdu.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pdu_block</td><td>Array of structs representing a Root Layer PDU block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_pdus</td><td>Size of the pdu_block array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Buffer size to allocate. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
