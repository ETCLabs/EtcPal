Whoa, this isn't a real source file! What's going on here? Well, the headers
for this module are platform-specific, and some of them implement types and
functions differently (i.e. functions as macros, etc.), so the documentation
needs somewhere to pull a standard interface from. Voila!

/*! \defgroup lwpa_lock lwpa_lock
 *  \ingroup lwpa
 *  \brief Platform-neutral locks, mutexes and signals.
 *
 *  \#include "lwpa_lock.h"
 *
 *  @{
 */

/*! \defgroup lwpa_mutex lwpa_mutex
 *  \brief A mutual-exclusion (mutex) object.
 *
 *  Sometimes also referred to as a critical section. Only one thread can take
 *  the mutex at a time using lwpa_mutex_take(). Where possible on real-time
 *  platforms, the mutex provides priority inheritance.
 *
 *  lwpa_mutex implementations use the following constructs under the hood on
 *  various platforms:
 * 
 *  On: | lwpa_mutex uses:
 *  ----------------------
 *  Windows | [Critical Section objects](https://msdn.microsoft.com/en-us/library/windows/desktop/ms682530(v=vs.85).aspx)
 *  FreeRTOS/lwIP | [Mutexes](https://www.freertos.org/Real-time-embedded-RTOS-mutexes.html)
 *  MQX | Lightweight Semaphores
 *
 *  @{
 */

/*! \brief The mutex identifier.
 *
 *  Depending on the platform, this could be a scalar type or a struct.
 */
typedef UNDEFINED lwpa_mutex_t;

/*! \brief Create a new mutex.
 *  \param[in,out] id Mutex identifier on which to create a mutex. If this
 *                    function returns true, id becomes valid for calls to
 *                    lwpa_mutex_take() and lwpa_mutex_give().
 *  \return true (the mutex was created) or false (the mutex was not created).
 */
bool lwpa_mutex_create(lwpa_mutex_t *id);

/*! \brief Acquire a mutex.
 *  \param[in] id Identifier for the mutex to acquire.
 *  \param[in] wait_ms How long to wait to acquire the mutex, in milliseconds
 *                     (use #LWPA_WAIT_FOREVER to wait indefinitely).
 *  \return true (the mutex was acquired) or false (timeout or failure while
 *               waiting to acquire the mutex).
 */
bool lwpa_mutex_take(lwpa_mutex_t *id, int wait_ms);

/*! \brief Release a mutex.
 *  \param[in] id Identifier for the mutex to release.
 */
void lwpa_mutex_give(lwpa_mutex_t *id);

/*! \brief Destroy a mutex object.
 *  \param[in] id Identifier for the mutex to destroy.
 */
void lwpa_mutex_destroy(lwpa_mutex_t *id);

/*!@}*/

/*! \defgroup lwpa_signal lwpa_signal
 *  \brief A signal object.
 *
 *  Sometimes also referred to as a binary semaphore or event. Used for thread
 *  synchronization; a call to lwpa_signal_wait() blocks until
 *  lwpa_signal_post() is called.
 *
 *  @{
 */

/*! \brief The signal identifier.
 *
 *  Depending on the platform, this could be a scalar type or a struct.
 */
typedef UNDEFINED lwpa_signal_t;

/*! \brief Create a new signal.
 *
 *  Signals are created in the "unsignaled" state; that is, the first call to
 *  lwpa_signal_wait() will block.
 *
 *  \param[in,out] id Signal identifier on which to create a signal. If this
 *                    function returns true, id becomes valid for calls to
 *                    lwpa_signal_wait() and lwpa_signal_post().
 *  \return true (the signal was created) or false (the signal was not created).
 */
bool lwpa_signal_create(lwpa_signal_t *id);

/*! \brief Wait for a signal.
 *
 *  If this is the first call to lwpa_signal_wait() after the signal object has
 *  been posted via lwpa_signal_post(), returns immediately. Otherwise, blocks
 *  until a call to lwpa_signal_post() on the signal object.
 *
 *  \param[in] id Identifier for the signal for which to wait.
 *  \param[in] wait_ms How long to wait for the signal, in milliseconds (use
 *                     #LWPA_WAIT_FOREVER to wait indefinitely).
 *  \return true (the signal was received) or false (timeout or failure while
 *               waiting for the signal).
 */
bool lwpa_signal_wait(lwpa_signal_t *id, int wait_ms);

/*! \brief Post a signal.
 *
 *  If no threads are waiting for the signal, puts the signal object in the
 *  "signaled" state (a subsequent call to lwpa_signal_wait() will return
 *  immediately). Otherwise, wakes up the first thread that waited for the
 *  signal.
 *
 *  \param[in] id Identifier for the signal to post.
 */
void lwpa_signal_post(lwpa_signal_t *id);

/*! \brief Destroy a signal object.
 *  \param[in] id Identifier for the signal to destroy.
 */
void lwpa_signal_destroy(lwpa_signal_t *id);

/*!@}*/

/*! \defgroup lwpa_rwlock lwpa_rwlock
 *  \brief A reader-writer lock object.
 *
 *  Sometimes also referred to as a shared-exclusive lock or multi-reader lock.
 *  When implemented to protect a resource, allows multiple "readers" to access
 *  the resource at the same time for read-only purposes.
 *
 *  These are implemented as "write-preferring" reader-writer locks; this means
 *  that new readers are blocked from acquiring a read lock if any context is
 *  currently waiting for a write lock.
 *
 *  @{
 */

/*! \brief The read-write lock identifier.
 *
 *  This is highly likely to be a struct.
 */
typedef UNDEFINED lwpa_rwlock_t;

/*! \brief Create a new read-write lock.
 *  \param[in,out] id Read-write lock identifier on which to create a read-write
 *                    lock. If this function returns true, id becomes valid for
 *                    calls to lwpa_rwlock_readlock(), lwpa_rwlock_writelock(),
 *                    etc.
 *  \return true (the read-write lock was created) or false (the read-write lock
 *               was not created).
 */
bool lwpa_rwlock_create(lwpa_rwlock_t *id);

/*! \brief Access a read-write lock for reading.
 *
 *  Blocks until any write lock has been released. Multiple contexts may have
 *  a read lock simultaneously. In typical usage, the resource protected by this
 *  lock should only be read, not modified, while inside a read lock.
 *
 *  \param[in] id Identifier for the read-write lock on which to acquire a read
 *                lock.
 *  \param[in] wait_ms How long to wait to acquire the read lock, in
 *                     milliseconds (use #LWPA_WAIT_FOREVER to wait
 *                     indefinitely).
 *  \return true (the read lock was acquired) or false (timeout or failure while
 *               waiting to acquire the read lock).
 */
bool lwpa_rwlock_readlock(lwpa_rwlock_t *id, int wait_ms);

/*! \brief Release a read lock on a read-write lock object.
 *  \param[in] id Identifier for the read-write lock on which to release the
 *                read lock.
 */
void lwpa_rwlock_readunlock(lwpa_rwlock_t *id);

/*! \brief Access a read-write lock for writing.
 *
 *  Blocks until all read and write locks have been released. No new read locks
 *  are allowed while this function is being blocked on.
 *
 *  \param[in] id Identifier for the read-write lock on which to acquire a write
 *                lock.
 *  \param[in] wait_ms How long to wait to acquire the write lock, in
 *                     milliseconds (use #LWPA_WAIT_FOREVER to wait
 *                     indefinitely).
 *  \return true (the write lock was acquired) or false (timeout or failure
 *               while waiting to acquire the write lock).
 */
bool lwpa_rwlock_writelock(lwpa_rwlock_t *id, int wait_ms);

/*! \brief Release a write lock on a read-write lock object.
 *  \param[in] id Identifier for the read-write lock on which to release the
 *                write lock.
 */
void lwpa_rwlock_writeunlock(lwpa_rwlock_t *id);

/*! \brief Destroy a read-write lock object.
 *  \param[in] id Identifier for the read-write lock object to destroy.
 */
void lwpa_rwlock_destroy(lwpa_rwlock_t *id);

/*!@}*/

/*!@}*/
